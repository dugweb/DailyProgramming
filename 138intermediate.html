<html>
<head>

<style>
* {
	padding:0;
	margin:0;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>

document.addEventListener("DOMContentLoaded", init);

function $(id) {
	return document.getElementById(id);
}

function init() {
	var can = new canvasController($('canvas'));
}


var circle = function(centerPoint) {

	/* ---------------------------------------
	|
	|  Public Methods & properties
	|  Create and store drawn circle info
	|
	|  --------------------------------------- */
	
	this.setMouseEnd = function(mousePoint) {
		if (self.mouseBegin) {
			self.mouseEnd = mousePoint;
			self.radius = calculateRadius(self.mouseBegin, self.mouseEnd);
			self.area = calculateArea(self.radius);
		}
		
	}
	
	/* ---------------------------------------
	|
	|  Private Methods 
	|
	|  --------------------------------------- */

	var self = this;

	init = function(centerPoint) {
		self.mouseBegin = centerPoint;
	}

	calculateRadius = function(beginPoint, endPoint) {
		var x1 = beginPoint.x, x2 = endPoint.x, y1 = beginPoint.y, y2 = endPoint.y, radius;

		
		radius = Math.floor(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)));

		return radius;
	}

	calculateArea = function(r) {
		return Math.PI * Math.pow(r, 2);
	}

	init(centerPoint);
}

var canvasController = function(el) {

	/* ---------------------------------------
	|
	|  Public Methods & properties
	|  This is for working with the canvas
	|  element.
	|
	|  --------------------------------------- */

	this.getCircles = function() {
		return circles;
	}
	
	/* ---------------------------------------
	|
	|  Private Methods 
	|
	|  --------------------------------------- */

	var canvasEl,
		canvasContext,
		isDrawing,
		circles,
		lastCircle,
		curCircle,
		circDistance,
		points = {},
		self = this;

	init = function(canvasElement) {
		canvasEl = canvasElement;
		canvasContext = canvasEl.getContext('2d');

		window.addEventListener("resize", resizeHandler);
		canvasEl.addEventListener("mousedown", downHandler);
		canvasEl.addEventListener("mouseup", upHandler);

		resizeHandler();

		isDrawing = false;
		circles = [];
	}

	resizeHandler = function() {
		canvasEl.width = window.innerWidth;
		canvasEl.height = window.innerHeight;
	}

	downHandler = function(e) {
		circles.push(new circle({x: e.clientX, y: e.clientY}));
		curCircle = circles[circles.length - 1];

		canvasEl.addEventListener("mousemove", moveHandler);

		if (lastCircle) {
			distance = calcDistance(lastCircle, curCircle);
		}

		updateCanvas();
		
	}

	moveHandler = function(e) {
		curCircle.setMouseEnd({x: e.clientX, y: e.clientY});

		if (lastCircle) {
			if (doCirclesIntersect(lastCircle, curCircle, distance)) {

			}
		}
		
		

		updateCanvas();
	}

	upHandler = function(e) {
		lastCircle = curCircle;

		canvasEl.removeEventListener('mousemove', moveHandler);
	}

	updateCanvas = function() {
		canvasContext.clearRect(0,0, canvasEl.width, canvasEl.height);
		canvasContext.beginPath();


		for (var i = circles.length - 2; i < circles.length; i++) {
			if (circles[i] === undefined) { continue; }
			canvasContext.moveTo(circles[i].mouseBegin.x + circles[i].radius, circles[i].mouseBegin.y)
			canvasContext.arc(circles[i].mouseBegin.x, circles[i].mouseBegin.y, circles[i].radius, 0, 2*Math.PI);
			if (points.p0 !== undefined) {
				drawPoint(points.p0);
			}
			if (points.p1 !== undefined) {
				drawPoint(points.p1);
			}
			if (points.p2 !== undefined) {
				drawPoint(points.p2);
			}
				
		}
		canvasContext.stroke();
	}

	drawPoint = function(point) {
		canvasContext.moveTo(point.x, point.y);
		canvasContext.arc(point.x, point.y, 2, 0, 2*Math.PI);
	}

	/* ========= Circle calculating functions ======== */

	calcDistance = function(p1, p2) {
		d = Math.sqrt(Math.pow(p2.mouseBegin.x - p1.mouseBegin.x, 2) + Math.pow(p2.mouseBegin.y - p1.mouseBegin.y, 2));
		return d;
	}

	doCirclesIntersect = function(c1, c2, d) {
		var result = false;
		
		if (d === 0 && c1.radius === c2.radius) {
			result = false; // Same circle, infinite intersections
		} else if (c1.radius + c2.radius > d && d > Math.abs(c1.radius - c2.radius)) {
			result = true;
			
			findIntersectingPoints(c1, c2, d);

		}

		return result;
	}

	// Great tutorial on how to find intersecting points of circles
	// http://paulbourke.net/geometry/circlesphere/

	findIntersectingPoints = function(c1, c2, d) {
		var a = (Math.pow(c1.radius, 2) - Math.pow(c2.radius, 2) + Math.pow(d, 2)) / (d * 2);
		var h = Math.sqrt(Math.pow(c1.radius, 2) - Math.pow(a, 2));

		p0 = {}; // point where line between circles, and intersecting line meet.

		p0.x = c1.mouseBegin.x + (a / d) * ( c2.mouseBegin.x - c1.mouseBegin.x);
		p0.y = c1.mouseBegin.y + (a / d) * ( c2.mouseBegin.y - c1.mouseBegin.y);
		

		p1 = {};
		p2 = {};

		p1.x = p0.x + ( h/d ) * ( c2.mouseBegin.y - c1.mouseBegin.y );
		p1.y = p0.y - ( h/d ) * ( c2.mouseBegin.x - c1.mouseBegin.x );

		p2.x = p0.x - ( h/d ) * ( c2.mouseBegin.y - c1.mouseBegin.y );
		p2.y = p0.y + ( h/d ) * ( c2.mouseBegin.x - c1.mouseBegin.x );

		points = {
			"p0" : p0,
			"p1" : p1,
			"p2" : p2
		}


	}

	init(el);
}



</script>
</body>
</html>